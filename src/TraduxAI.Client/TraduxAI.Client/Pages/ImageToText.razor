@page "/image-to-text"
@attribute [Authorize]
@using DocumentFormat.OpenXml
@using DocumentFormat.OpenXml.Packaging
@using DocumentFormat.OpenXml.Wordprocessing
@using TraduxAI.Client.Models
@using TraduxAI.Client.Services
@using TraduxAI.Client.Components
@inject IDocumentProcessingService DocumentService
@inject IJSRuntime JSRuntime
@inject IAuthService AuthService

<h3 class="fw-bold">Image To Text</h3>

<div class="row">
	<div class="col-md-6">
		<FileUpload Accept="image/*" OnFileSelected="HandleImageSelected" />

		@if (!string.IsNullOrEmpty(PreviewUrl))
		{
			<div class="mb-3">
				<img src="@PreviewUrl" class="img-fluid border rounded" alt="Selected image" />
			</div>
		}

		<button class="btn btn-success me-2" @onclick="ProcessImage" disabled="@(!CanExecute)">
			Execute Image to Text
		</button>

		<button class="btn btn-danger" @onclick="ClearPage" disabled="@(!CanClear)">
			Clear Page
		</button>

		@if (IsProcessing)
		{
			<div class="mt-2">
				<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
				<span>Processing...</span>
			</div>
		}
	</div>

	<div class="col-md-6">
		<div class="mb-3">
			<label class="form-label fw-bold">Extracted Text</label>
			<textarea class="form-control" rows="10" @bind="ExtractedText" readonly></textarea>
		</div>

		@if (!string.IsNullOrEmpty(ExtractedText))
		{

			<div class="d-flex gap-2">
				<button class="btn btn-secondary" @onclick="CopyToClipboard">
					<i class="bi bi-clipboard"></i> Copy
				</button>
				<button class="btn btn-primary" @onclick="ExportarDocumento">
					<i class="bi bi-file-earmark-word"></i> Export to Word
				</button>
			</div>
		}
	</div>
</div>

@code {
	private IBrowserFile? SelectedFile;
	private string? PreviewUrl;
	private string ExtractedText = string.Empty;
	private bool IsProcessing = false;
	private bool CanExecute => SelectedFile != null && !IsProcessing;
	private bool CanClear => !string.IsNullOrEmpty(ExtractedText) || !string.IsNullOrEmpty(PreviewUrl);



	private async Task HandleImageSelected(IBrowserFile file)
	{
		SelectedFile = file;
		ExtractedText = string.Empty;
		// Para la vista previa: leer el archivo y convertir a base64
		using var stream = file.OpenReadStream(file.Size);
		using var ms = new MemoryStream();
		await stream.CopyToAsync(ms);
		PreviewUrl = $"data:{file.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}";
	}
	private async Task ProcessImage()
	{
		if (SelectedFile == null) return;

		IsProcessing = true;
		try
		{
			var token = await WaitForToken();
			using var stream = SelectedFile.OpenReadStream(10 * 1024 * 1024);
			using var ms = new MemoryStream();
			await stream.CopyToAsync(ms);
			var imageBytes = ms.ToArray();

			var result = await DocumentService.ProcessImageToTextAsync(imageBytes, token);
			ExtractedText = result.ProcessedContent;
		}
		catch (Exception ex)
		{
			ExtractedText = $"Error: {ex.Message}";
		}
		finally
		{
			IsProcessing = false;
		}
	}

	private async Task CopyToClipboard()
	{
		await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", ExtractedText);
	}

	private async Task<string> WaitForToken()
	{
		for (int i = 0; i < 10; i++)
		{
			await Task.Delay(1000);
			var token = await AuthService.GetTokenAsync();
			if (!string.IsNullOrEmpty(token)) return token;

			await Task.Delay(1000);
		}

		throw new Exception("Token Jwt No disponible despues de esperar");
	}

	private void ClearPage()
	{
		SelectedFile = null;
		PreviewUrl = null;
		ExtractedText = string.Empty;
	}

	private async Task ExportarDocumento()
	{
		if (string.IsNullOrEmpty(ExtractedText))
			return;
		try
		{
			await ExportToWord(ExtractedText);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error exporting document: {ex.Message}");
		}
	}

	public async Task ExportToWord(string contenido, string nombreArchivo = "documento.docx")
	{
		// Crear el archivo en memoria
		using (MemoryStream ms = new MemoryStream())
		{
			// Crear el documento Word
			using (WordprocessingDocument wordDoc = WordprocessingDocument.Create(ms, WordprocessingDocumentType.Document))
			{
				// Añadir una parte principal del documento
				MainDocumentPart mainPart = wordDoc.AddMainDocumentPart();
				mainPart.Document = new Document();
				Body body = mainPart.Document.AppendChild(new Body());

				// Procesar el contenido y crear párrafos con formato
				string[] parrafos = contenido.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

				foreach (string parrafoTexto in parrafos)
				{
					if (string.IsNullOrWhiteSpace(parrafoTexto))
						continue;

					Paragraph parrafo = new Paragraph();
					Run run = new Run();
					Text texto = new Text(parrafoTexto);

					run.AppendChild(texto);
					parrafo.AppendChild(run);
					body.AppendChild(parrafo);
				}

				// Guardar el documento
				mainPart.Document.Save();
			}

			// Descargar el archivo
			await DescargarArchivo(ms.ToArray(), nombreArchivo, "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
		}
	}

	// Método para descargar el archivo usando JavaScript
	private async Task DescargarArchivo(byte[] contenido, string nombreArchivo, string contentType)
	{
		// Convertir el array de bytes a base64
		string base64 = Convert.ToBase64String(contenido);

		// Usar JSRuntime para descargar el archivo
		await JSRuntime.InvokeVoidAsync("descargarArchivo", base64, nombreArchivo, contentType);
	}
}
