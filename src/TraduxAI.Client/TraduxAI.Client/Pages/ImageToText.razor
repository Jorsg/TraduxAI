@page "/image-to-text"
@attribute [Authorize]
@using DocumentFormat.OpenXml
@using DocumentFormat.OpenXml.Packaging
@using DocumentFormat.OpenXml.Wordprocessing
@using TraduxAI.Client.Models
@using TraduxAI.Client.Services
@using TraduxAI.Client.Components
@inject IDocumentProcessingService DocumentService
@inject IJSRuntime JSRuntime
@inject CookieService CookieAuthService
@inject IAuthService AuthService

<!-- NAVBAR -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top shadow-sm mb-4">
	<div class="container-fluid">
		<a class="navbar-brand fw-bold fs-4" href="">Tradux-AI</a>
		<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mainNav" aria-controls="mainNav" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		</button>
		<div class="collapse navbar-collapse justify-content-end" id="mainNav">
			<ul class="navbar-nav mb-2 mb-lg-0">
				<li class="nav-item">
					<NavLink class="nav-link" href="/" Match="NavLinkMatch.All">
						<span class="oi oi-home" aria-hidden="true"></span> Home
					</NavLink>
				</li>
				<li class="nav-item">
					<NavLink class="nav-link" href="image-to-text">
						<span class="oi oi-plus" aria-hidden="true"></span> Image To Text
					</NavLink>
				</li>
				<li class="nav-item">
					<NavLink class="nav-link" href="pdf-to-text">
						<span class="oi oi-list-rich" aria-hidden="true"></span> PDF To Text
					</NavLink>
				</li>
				<li class="nav-item">
					<NavLink class="nav-link" href="translate">
						<span class="oi oi-list-rich" aria-hidden="true"></span> Translate
					</NavLink>
				</li>
			</ul>
			<button class="btn btn-outline-light ms-3" @onclick="Logout">
				<span class="oi oi-account-logout" aria-hidden="true"></span> Logout
			</button>
		</div>
	</div>
</nav>

<div class="container py-5">
	<div class="row justify-content-center">
		<div class="col-12 col-lg-10">
			<div class="jumbotron bg-light p-4 rounded-4 shadow-sm text-center mb-5">
				<h2 class="display-6 fw-bold mb-2">Image To Text</h2>
				<p class="lead mb-1">
					Extract text from your images using AI-powered OCR.
				</p>
			</div>
			<div class="row g-4">
				<!-- Left: Upload and Actions -->
				<div class="col-12 col-md-6">
					<div class="card h-100 shadow rounded-4 border-0">
						<div class="card-body">
							<FileUpload Accept="image/*" OnFileSelected="HandleImageSelected" @key="fileUploadKey" />
							@if (!string.IsNullOrEmpty(PreviewUrl))
							{
								<div class="mb-3 mt-3 text-center">
									<img src="@PreviewUrl" class="img-fluid border rounded shadow" style="max-height:250px;object-fit:contain;" alt="Selected image" />
								</div>
							}
							<div class="d-flex align-items-center gap-3 mt-4">
								<button class="btn btn-success" @onclick="ProcessImage" disabled="@(!CanExecute)">
									<i class="bi bi-image"></i> Execute Image to Text
								</button>
								<button class="btn btn-danger" @onclick="ClearPage" disabled="@(!CanClear)">
									Clear Page
								</button>
							</div>
							@if (IsProcessing)
							{
								<div class="mt-3">
									<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
									<span class="ms-2 text-muted">Processing...</span>
								</div>
							}
						</div>
					</div>
				</div>
				<!-- Right: Output -->
				<div class="col-12 col-md-6">
					<div class="card h-100 shadow rounded-4 border-0">
						<div class="card-body">
							<div class="mb-3">
								<label class="form-label fw-bold">Extracted Text</label>
								<textarea class="form-control" rows="10" @bind="ExtractedText" readonly placeholder="The extracted text will appear here."></textarea>
							</div>
							@if (!string.IsNullOrEmpty(ExtractedText))
							{
								<div class="d-flex gap-2 mt-2">
									<button class="btn btn-secondary" @onclick="CopyToClipboard">
										<i class="bi bi-clipboard"></i> Copy
									</button>
									<button class="btn btn-primary" @onclick="ExportarDocumento">
										<i class="bi bi-file-earmark-word"></i> Export to Word
									</button>
								</div>
							}
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

@code {
	private IBrowserFile? SelectedFile;
	private string? PreviewUrl;
	private string ExtractedText = string.Empty;
	private bool IsProcessing = false;
	private Guid fileUploadKey = Guid.NewGuid();
	private bool CanExecute => SelectedFile != null && !IsProcessing;
	private bool CanClear => !string.IsNullOrEmpty(ExtractedText) || !string.IsNullOrEmpty(PreviewUrl);



	private async Task HandleImageSelected(IBrowserFile file)
	{
		SelectedFile = file;
		ExtractedText = string.Empty;
		// Para la vista previa: leer el archivo y convertir a base64
		using var stream = file.OpenReadStream(file.Size);
		using var ms = new MemoryStream();
		await stream.CopyToAsync(ms);
		PreviewUrl = $"data:{file.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}";
	}
	private async Task ProcessImage()
	{
		if (SelectedFile == null) return;

		IsProcessing = true;
		try
		{
			var token = await WaitForToken();
			using var stream = SelectedFile.OpenReadStream(10 * 1024 * 1024);
			using var ms = new MemoryStream();
			await stream.CopyToAsync(ms);
			var imageBytes = ms.ToArray();

			var result = await DocumentService.ProcessImageToTextAsync(imageBytes, token);
			ExtractedText = result.ProcessedContent;
		}
		catch (Exception ex)
		{
			ExtractedText = $"Error: {ex.Message}";
		}
		finally
		{
			IsProcessing = false;
		}
	}

	private async Task CopyToClipboard()
	{
		await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", ExtractedText);
	}

	private async Task<string> WaitForToken()
	{

		for (int i = 0; i < 10; i++)
		{
			await Task.Delay(1000);
			var token = await CookieAuthService.GetCookie("access_token");
			if (!string.IsNullOrEmpty(token)) return token;

			await Task.Delay(1000);
		}

		throw new Exception("Token Jwt No disponible despues de esperar");
	}

	private void ClearPage()
	{
		SelectedFile = null;
		PreviewUrl = null;
		ExtractedText = string.Empty;
		fileUploadKey = Guid.NewGuid();
	}

	private async Task ExportarDocumento()
	{
		if (string.IsNullOrEmpty(ExtractedText))
			return;
		try
		{
			await ExportToWord(ExtractedText);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error exporting document: {ex.Message}");
		}
	}

	public async Task ExportToWord(string contenido, string nombreArchivo = "documento.docx")
	{
		// Crear el archivo en memoria
		using (MemoryStream ms = new MemoryStream())
		{
			// Crear el documento Word
			using (WordprocessingDocument wordDoc = WordprocessingDocument.Create(ms, WordprocessingDocumentType.Document))
			{
				// Añadir una parte principal del documento
				MainDocumentPart mainPart = wordDoc.AddMainDocumentPart();
				mainPart.Document = new Document();
				Body body = mainPart.Document.AppendChild(new Body());

				// Procesar el contenido y crear párrafos con formato
				string[] parrafos = contenido.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

				foreach (string parrafoTexto in parrafos)
				{
					if (string.IsNullOrWhiteSpace(parrafoTexto))
						continue;

					Paragraph parrafo = new Paragraph();
					Run run = new Run();
					Text texto = new Text(parrafoTexto);

					run.AppendChild(texto);
					parrafo.AppendChild(run);
					body.AppendChild(parrafo);
				}

				// Guardar el documento
				mainPart.Document.Save();
			}

			// Descargar el archivo
			await DescargarArchivo(ms.ToArray(), nombreArchivo, "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
		}
	}

	// Método para descargar el archivo usando JavaScript
	private async Task DescargarArchivo(byte[] contenido, string nombreArchivo, string contentType)
	{
		// Convertir el array de bytes a base64
		string base64 = Convert.ToBase64String(contenido);

		// Usar JSRuntime para descargar el archivo
		await JSRuntime.InvokeVoidAsync("descargarArchivo", base64, nombreArchivo, contentType);
	}

	private async Task Logout()
	{
		await AuthService.LogoutAsync();
	}
}
