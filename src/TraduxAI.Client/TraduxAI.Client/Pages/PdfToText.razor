@page "/pdf-to-text"
@attribute [Authorize]
@using TraduxAI.Client.Models
@using TraduxAI.Client.Services
@inject IDocumentProcessingService DocumentService
@using TraduxAI.Client.Components
@inject IJSRuntime JSRuntime
@inject IAuthService AuthService

<h3 class="fw-bold">PDF To Text</h3>
<div class="row">
	<div class="col-md-6">

		<FileUpload Accept=".pdf" OnFileSelected="HandlePdfSelected" />

		@if (!string.IsNullOrEmpty(FileName))
		{
			<div class="mb-3">
				<div class="card p-3">
					<i class="bi bi-file-pdf" style="font-size: 2rem;"></i>
					<p class="mb-0">@FileName</p>
				</div>
			</div>
		}
		<input type="submit" class="btn btn-success" value="Execute pdf to text" onclick="@ProcessPdf" disabled="@(PdfBytes == null || IsProcessing)" />
		
		@if (IsProcessing)
		{
			<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
			<span>Processing...</span>
		}
	
	</div>

	<div class="col-md-6">
		<div class="mb-3">
			<label class="form-label fw-bold">Extracted Text</label>
			<textarea class="form-control" rows="10" @bind="ExtractedText" readonly />
		</div>
	</div>
	@if (!string.IsNullOrEmpty(ExtractedText))
	{
		<button class="btn btn-secondary" @onclick="CopyToClipboard">Copy to Clipboard</button>
	}
</div>
@code {
	private byte[]? PdfBytes;
	private string FileName = string.Empty;
	private string ExtractedText = string.Empty;
	private bool IsProcessing = false;

	private async Task HandlePdfSelected(IBrowserFile file)
	{
		FileName = file.Name;
		ExtractedText = string.Empty;
		using var stream = file.OpenReadStream(20 * 1024 * 1024);
		using var ms = new MemoryStream();
		await stream.CopyToAsync(ms);
		PdfBytes = ms.ToArray();
	}


	private async Task ProcessPdf()
	{
		if (PdfBytes == null) return;

		IsProcessing = true;
		try
		{
			var token = await WaitForToken();
			var result = await DocumentService.ProcessPdfToTextAsync(PdfBytes, token);
			ExtractedText = result.ProcessedContent;
		}
		catch (Exception ex)
		{
			ExtractedText = $"Error: {ex.Message}";
		}
		finally
		{
			IsProcessing = false;
		}
	}

	private async Task CopyToClipboard()
	{
		await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", ExtractedText);
	}

	private async Task<string> WaitForToken()
	{
		for (int i = 0; i < 10; i++)
		{
			await Task.Delay(1000);
			var token = await AuthService.GetTokenAsync();
			if (!string.IsNullOrEmpty(token)) return token;

			await Task.Delay(1000);
		}

		throw new Exception("Token Jwt No disponible despues de esperar");
	}
}
