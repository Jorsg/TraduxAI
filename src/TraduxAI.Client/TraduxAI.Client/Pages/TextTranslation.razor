@page "/translate"
@attribute [Authorize]
@using TraduxAI.Client.Models
@using TraduxAI.Client.Services
@inject IDocumentProcessingService DocumentService
@inject IJSRuntime JSRuntime
@inject IAuthService AuthService
@using DocumentFormat.OpenXml;
@using DocumentFormat.OpenXml.Packaging;
@using DocumentFormat.OpenXml.Wordprocessing

<h3 class="fw-bold mb-4">Text Translation</h3>

<div class="row">
	<!-- Columna izquierda: Entrada -->
	<div class="col-md-6">
		<div class="mb-3">
			<label class="form-label fw-bold">Source Language</label>
			<select class="form-select" @bind="SourceLanguage">
				@foreach (var lang in Languages)
				{
					<option value="@lang.Code">@lang.Label</option>
				}
			</select>
		</div>

		<div class="mb-3">
			<label class="form-label fw-bold">Source Text</label>
			<textarea class="form-control" rows="8" @bind="SourceText" placeholder="Enter text to translate..."></textarea>
		</div>

		<div class="mb-3">
			<label class="form-label fw-bold">Prompt</label>
			<input class="form-control" type="text" placeholder="Enter a prompt (optional)" @bind="Prompt" />
		</div>

		<div class="d-flex align-items-center gap-3">
			<button class="btn btn-success" @onclick="TranslateText" disabled="@(!CanExecute || IsProcessing)">
				<i class="bi bi-translate"></i> Translate
			</button>

			<button class="btn btn-danger" @onclick="ClearPage" disabled="@(!CanClear)">
				Clear Page
			</button>

			@if (IsProcessing)
			{
				<div class="d-flex align-items-center">
					<div class="spinner-border spinner-border-sm text-primary me-2" role="status" aria-hidden="true"></div>
					<span class="text-muted">Translating...</span>
				</div>
			}
		</div>
	</div>

	<!-- Columna derecha: Salida -->
	<div class="col-md-6">
		<div class="mb-3">
			<label class="form-label fw-bold">Target Language</label>
			<select class="form-select" @bind="TargetLanguage">
				@foreach (var lang in Languages.Where(l => l.Code != "auto"))
				{
					<option value="@lang.Code">@lang.Label</option>
				}
			</select>
		</div>

		<div class="mb-3">
			<label class="form-label fw-bold">Translated Text</label>
			<textarea class="form-control" rows="8" @bind="TranslatedText" readonly placeholder="The translated text will appear here."></textarea>
		</div>

		@if (!string.IsNullOrEmpty(TranslatedText))
		{
			<div class="d-flex gap-2">
				<button class="btn btn-secondary" @onclick="CopyToClipboard">
					<i class="bi bi-clipboard"></i> Copy
				</button>
				<button class="btn btn-primary" @onclick="ExportarDocumento">
					<i class="bi bi-file-earmark-word"></i> Export to Word
				</button>
			</div>
		}
	</div>
</div>

@code {
	private string SourceText = string.Empty;
	private string TranslatedText = string.Empty;
	private string SourceLanguage = "auto";
	private string TargetLanguage = "en";
	private bool IsProcessing = false;
	private string Prompt = string.Empty;
	private bool CanExecute => SourceText != null && !IsProcessing;
	private bool CanClear => !string.IsNullOrEmpty(TranslatedText) || !string.IsNullOrEmpty(Prompt);


	private List<(string Code, string Label)> Languages = new()
	{
		("auto", "Auto Detect"),
		("en", "English"),
		("es", "Spanish"),
		("fr", "French"),
	};

	private async Task TranslateText()
	{
		if (string.IsNullOrWhiteSpace(SourceText) && string.IsNullOrWhiteSpace(Prompt)) return;
		IsProcessing = true;
		try
		{
			var token = await WaitForToken();
			var promtsSourceTest = $"{Prompt} {SourceText}";
			var result = await DocumentService.TranslateTextAsync(promtsSourceTest, SourceLanguage, TargetLanguage, token);
			TranslatedText = result.ProcessedContent;
		}
		catch (Exception ex)
		{
			TranslatedText = $"Error: {ex.Message}";
		}
		finally
		{
			IsProcessing = false;
		}
	}

	private async Task CopyToClipboard()
	{
		await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", TranslatedText);
	}

	private void ClearPage()
	{
		SourceText = null;
		Prompt = null;
		TranslatedText = string.Empty;
	}

	private async Task<string> WaitForToken()
	{
		for (int i = 0; i < 10; i++)
		{
			await Task.Delay(1000);
			var token = await AuthService.GetTokenAsync();
			if (!string.IsNullOrEmpty(token)) return token;

			await Task.Delay(1000);
		}

		throw new Exception("Token Jwt No disponible despues de esperar");
	}

	private async Task ExportarDocumento()
	{
		if (string.IsNullOrEmpty(TranslatedText))
			return;
		try
		{
			await ExportToWord(TranslatedText);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error exporting document: {ex.Message}");
		}
	}

	public async Task ExportToWord(string contenido, string nombreArchivo = "documento.docx")
	{
		// Crear el archivo en memoria
		using (MemoryStream ms = new MemoryStream())
		{
			// Crear el documento Word
			using (WordprocessingDocument wordDoc = WordprocessingDocument.Create(ms, WordprocessingDocumentType.Document))
			{
				// Añadir una parte principal del documento
				MainDocumentPart mainPart = wordDoc.AddMainDocumentPart();
				mainPart.Document = new Document();
				Body body = mainPart.Document.AppendChild(new Body());

				// Procesar el contenido y crear párrafos con formato
				string[] parrafos = contenido.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

				foreach (string parrafoTexto in parrafos)
				{
					if (string.IsNullOrWhiteSpace(parrafoTexto))
						continue;

					Paragraph parrafo = new Paragraph();
					Run run = new Run();
					Text texto = new Text(parrafoTexto);

					run.AppendChild(texto);
					parrafo.AppendChild(run);
					body.AppendChild(parrafo);
				}

				// Guardar el documento
				mainPart.Document.Save();
			}

			// Descargar el archivo
			await DescargarArchivo(ms.ToArray(), nombreArchivo, "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
		}
	}

	// Método para descargar el archivo usando JavaScript
	private async Task DescargarArchivo(byte[] contenido, string nombreArchivo, string contentType)
	{
		// Convertir el array de bytes a base64
		string base64 = Convert.ToBase64String(contenido);

		// Usar JSRuntime para descargar el archivo
		await JSRuntime.InvokeVoidAsync("descargarArchivo", base64, nombreArchivo, contentType);
	}


}
